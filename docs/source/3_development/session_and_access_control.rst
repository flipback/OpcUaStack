Session and Access Control
==========================

In this section we'll learn how to implement authentication and authorization
functionality in your application with ASNeG OPC UA Stack.

Overview
--------

After an OPC UA client has got :term:`Endpoint`\ s of the server by
using :ref:`discovery_process` and opened a :term:`Secure Channel` with suitable
:ref:`security_policy` and :ref:`security_mode`, it should create and activate
:term:`Session` with the server to access to the OPC UA application's data.
During the session activation the client authenticates itself by *userIdentityToken*
that allows the application to correspond the activated :term:`Session` with
its user profile. Then the client finishes communication with the server it
should close :term:`Session` by calling :term:`Service` *CloseSession* or it is
closed by the timeout.

ASNeG OPC UA Stack provides a callback mechanism to notify the user application
about activating\\closing session and accessing to the data during the current
session so that a developer can builtin authentication and authorization in its
OPC UA applications.

::

  Client              ASNeG OPC UA Stack                  User Application
  ======              ==================                  ================
    |                         |                                  |
    |                         |  Register Callbacks              |
    I                         I<---------------------------------I
    I    ActivateSession()    I                                  |
    I------------------------>I                                  |
    I                         I  Call Authentication Callback    |
    I                         I--------------------------------->I
    I                         I  OpcUaStatusCode::Success        I
    I    result = Success     I<---------------------------------I
    I<------------------------I                                  |
    I                         I                                  |
    I                         I                                  |
    I                         I                                  |
    I       Read()            I                                  |
    I------------------------>I  Call Authorization Callback     |
    I                         I--------------------------------->I
    I                         I  OpcUaStatusCode::Success        I
    I    result = Success     I<---------------------------------I
    I<------------------------I                                  |
    I                         I                                  |

                          (other calls of Services)

    I                         I                                  |
    I    CloseSession()       I                                  |
    I------------------------>I  Call CloseSession Callback      |
    |                         |--------------------------------->I
    I                         I  OpcUaStatusCode::Success        I
    I    result = Success     I<---------------------------------I
    I<------------------------I                                  |
    |                         |                                  |

Now we're going to see the callbacks in details. All the following examples are based
on a user application generated by *OpcUaProjectBuilder3*, so see :ref:`hello_world`
and :ref:`creating`.

Callback Registration
----------------------

The callback mechanism of the stack requires to create method-handlers
and register them in the stack by the startup of the application. To do it, declare
in **Library.h** the methods:

.. code-block:: cpp
  :emphasize-lines: 2-4,15-17

  #include "OpcUaStackCore/Application/ApplicationAuthenticationContext.h"
  #include "OpcUaStackCore/Application/ApplicationAutorizationContext.h"
  #include "OpcUaStackCore/Application/ApplicationCloseSessionContext.h"

  class Library
  : public ApplicationIf
  {
    public:
    Library(void);
    virtual ~Library(void);

    //- ApplicationIf -----------------------------------------------------
    virtual bool startup(void);
    virtual bool shutdown(void);
    virtual std::string version(void);
    //- ApplicationIf -----------------------------------------------------

    private:
    void authenticationCallback(ApplicationAuthenticationContext* applicationAuthenitcationContext);
    void closeSessionCallback(ApplicationCloseSessionContext* applicationCloseSessionContext);
    void autorizationCallback(ApplicationAutorizationContext* applicationAutorizationContext);
  };

And add the following code to **Library.cpp**:

.. code-block:: cpp

  #include "OpcUaStackServer/ServiceSetApplication/RegisterForwardGlobal.h"

  bool
  Library::startup(void)
  {

    RegisterForwardGlobal registerForwardGlobal;
    registerForwardGlobal.setAuthenticationCallback(boost::bind(&Library::authenticationCallback, this, _1));
    registerForwardGlobal.setAutorizationCallback(boost::bind(&Library::autorizationCallback, this, _1));
    registerForwardGlobal.setCloseSessionCallback(boost::bind(&Library::closeSessionCallback, this, _1));
    if (!registerForwardGlobal.query(&this->service())) {
        std::cout << "registerForwardGlobal response error" << std::endl;
        return false;
    }

    return true;
  }

  void
  Library::authenticationCallback(
      ApplicationAuthenticationContext* applicationAuthenitcationContext)
  {

  }

  void
  Library::closeSessionCallback(
      ApplicationCloseSessionContext* applicationCloseSessionContext)
  {

  }

  void
  Library::autorizationCallback(
      ApplicationAutorizationContext* applicationAutorizationContext)
  {

  }

As you can see, we use *RegisterForwardGlobal* transaction for the registration our
callbacks in the stack. We wrap our handler-methods in bind-objects and pass them
to the transaction then we call *query* to send callbacks to the stack.

When the subscribed events happen, the stack calls handler-methods and pass them *context*
with input information and get result of the callback with it as well.

We'll show you how it's working in the next sections.


Authentication
--------------

To implement the authentication, our example should have some
list of allowed users. Since we'll need to pass information about the current
user between the stack and the application, we represent the user as a class
based on *UserContext* and make a map (*userMap_*) of them in **Library.h**:


.. code-block:: cpp

	class UserProfile : public UserContext {
	public:
    typedef boost::shared_ptr<UserProfile> SPtr;
    typedef std::map<std::string, UserProfile::SPtr> Map;
		UserProfile(std::string username, std::string password, std::string access)
			: username_(username)
			, password_(password)
			, access_(access)
		{

		}

		std::string username_;
		std::string password_;
		std::string access_;
	};

  class Library
  : public ApplicationIf
  {
    public:
    Library(void);
    virtual ~Library(void);

    //- ApplicationIf -----------------------------------------------------
    virtual bool startup(void);
    virtual bool shutdown(void);
    virtual std::string version(void);
    //- ApplicationIf -----------------------------------------------------

    private:
      void authenticationCallback(ApplicationAuthenticationContext* applicationAuthenitcationContext);
      void closeSessionCallback(ApplicationCloseSessionContext* applicationCloseSessionContext);
      void autorizationCallback(ApplicationAutorizationContext* applicationAutorizationContext);

      UserProfile::Map userMap_;
  };

Now we're placing two users into the map in method *startup*. *User_RW* has right
to read and write data, *User_R* can only read:

.. code-block:: cpp

  bool
  Library::startup(void)
  {
      RegisterForwardGlobal registerForwardGlobal;
      registerForwardGlobal.setAuthenticationCallback(boost::bind(&Library::authenticationCallback, this, _1));
      registerForwardGlobal.setAutorizationCallback(boost::bind(&Library::autorizationCallback, this, _1));
      registerForwardGlobal.setCloseSessionCallback(boost::bind(&Library::closeSessionCallback, this, _1));
      if (!registerForwardGlobal.query(&this->service())) {
        std::cout << "registerForwardGlobal response error" << std::endl;
        return false;
      }

      userMap_ = UserProfile::Map();
      userMap_["User_RW"] = constructSPtr<UserProfile>("User_RW", "password1", "rw");
      userMap_["User_R"] = constructSPtr<UserProfile>("User_R", "password2", "r");

      return true;
  }

When we have the list of the allowed users, we can implement our authentication method:

.. code-block:: cpp

  #include "OpcUaStackCore/ServiceSet/UserNameIdentityToken.h" // don't forget include this

  // ...
  void
	Library::authenticationCallback(
			ApplicationAuthenticationContext* contex)
	{
		Log(Debug, "Event::authenticationCallback")
			.parameter("SessionId", contex->sessionId_);


		if (contex->authenticationType_ == OpcUaId_AnonymousIdentityToken_Encoding_DefaultBinary) {
			contex->statusCode_ = BadIdentityTokenRejected;
		}
		else if (contex->authenticationType_ == OpcUaId_UserNameIdentityToken_Encoding_DefaultBinary) {

			ExtensibleParameter::SPtr parameter = contex->parameter_;
			UserNameIdentityToken::SPtr token = parameter->parameter<UserNameIdentityToken>();

			// find user profile
			UserProfile::Map::iterator it;
			it = userMap_.find(token->userName());
			if (it == userMap_.end()) {
				contex->statusCode_ = BadUserAccessDenied;
				return;
			}

			UserProfile::SPtr userProfile = it->second;

			// check password
			if (token->password() != userProfile->password_) {
				contex->statusCode_ = BadUserAccessDenied;
				return;
			}

			contex->userContext_ = userProfile;
			contex->statusCode_ = Success;
		}
		else if (contex->authenticationType_ == OpcUaId_X509IdentityToken_Encoding_DefaultBinary) {
			contex->statusCode_ = BadIdentityTokenRejected;
		}
		else {
			contex->statusCode_ = BadIdentityTokenInvalid;
		}
	}

OPC UA Specification determines several kinds of authentication and the example
application supports only the identification by username and password. If the client tries to
authenticate itself with the unsupported type, the method notifies the stack about
it by writing status *BadIdentityTokenRejected* to the context:

.. code-block:: cpp

  contex->statusCode_ = BadIdentityTokenRejected;


The stack denies to open the session with the client.

In case, where the client uses *OpcUaId_UserNameIdentityToken_Encoding_DefaultBinary*
identity token, we can get from it the username and the password to check them:

.. code-block:: cpp

  if (contex->authenticationType_ == OpcUaId_UserNameIdentityToken_Encoding_DefaultBinary) {

    ExtensibleParameter::SPtr parameter = contex->parameter_;
    UserNameIdentityToken::SPtr token = parameter->parameter<UserNameIdentityToken>();

    // find user profile
    UserProfile::Map::iterator it;
    it = userMap_.find(token->userName());
    if (it == userMap_.end()) {
      contex->statusCode_ = BadUserAccessDenied;
      return;
    }

    UserProfile::SPtr userProfile = it->second;

    // check password
    if (token->password() != userProfile->password_) {
      contex->statusCode_ = BadUserAccessDenied;
      return;
    }

    contex->userContext_ = userProfile;
    contex->statusCode_ = Success;
  }

The authentication method should write into the context *BadUserAccessDenied* status
if there is no allowed user with the given username or the password mismatches.
The method should write into the context *Success* status if the authentication is
successful, so that the stack allows to open the session with the client. Pay attention,
that we've saved the authenticated user into the *context->userContext_*.
The stack connects the user to the activated session and passes it as a current
user with the context to all method-handlers of services during the session.  

Authorization
--------------

Close Session
--------------

References
-----------

* :ref:`security`
* :ref:`discovery_process`
* `Example <https://github.com/ASNeG/ASNeG-Demo/blob/master/src/ASNeG-Demo/Library/Authentication.cpp>`_

OPC UA Specification
--------------------

* Part 4 Services, 5.6 Session Service Set.
