Session and Access Control
==========================

In this section we'll learn how to implement authentication and authorization
functionality in your application with ASNeG OPC UA Stack.

Overview
--------

After an OPC UA client has got :term:`Endpoint`\ s of the server by
using :ref:`discovery_process` and opened a :term:`Secure Channel` with suitable
:ref:`security_policy` and :ref:`security_mode`, it should create and activate
:term:`Session` with the server to access to the OPC UA application's data with
During the session activation the client authenticates itself by *userIdentityToken*
that allows the application to correspond the activated :term:`Session` with
its user profile. Then the client finishes
communication with the server it should close :term:`Session` by calling
:term:`Service` *CloseSession* or it is closed by the timeout.

ASNeG OPC UA Stack provides a callback mechanism to notify the user application
about activating\\closing session and accessing to the data during the current
session so that a developer can builtin authentication and authorization in its
OPC UA applications.

::

  Client              ASNeG OPC UA Stack                  User Application
  ======              ==================                  ================
    |                         |                                  |
    |                         |  Register Callbacks              |
    I                         I<---------------------------------I
    I    ActivateSession()    I                                  |
    I------------------------>I                                  |
    I                         I  Call Authentication Callback    |
    I                         I--------------------------------->I
    I                         I  OpcUaStatusCode::Success        I
    I    result = Success     I<---------------------------------I
    I<------------------------I                                  |
    I                         I                                  |
    I                         I                                  |
    I                         I                                  |
    I       Read()            I                                  |
    I------------------------>I  Call Authorization Callback     |
    I                         I--------------------------------->I
    I                         I  OpcUaStatusCode::Success        I
    I    result = Success     I<---------------------------------I
    I<------------------------I                                  |
    I                         I                                  |

                          (other calls of Services)

    I                         I                                  |
    I    CloseSession()       I                                  |
    I------------------------>I  Call CloseSession Callback      |
    |                         |--------------------------------->I
    I                         I  OpcUaStatusCode::Success        I
    I    result = Success     I<---------------------------------I
    I<------------------------I                                  |
    |                         |                                  |

Now we're going to see the callbacks in details. All the following examples are based
on a user application generated by *OpcUaProjectBuilder3*, so see :ref:`hello_world`
and :ref:`creating`.

Callback Registration
----------------------

The callback mechanism of the stack requires to create method-handlers
and register them in the stack by the startup of the application. To do it, declare
in **Library.h** the methods:

.. code-block:: cpp
  :emphasize-lines: 2-4,15-17

  #include "OpcUaStackCore/Application/ApplicationAuthenticationContext.h"
  #include "OpcUaStackCore/Application/ApplicationAutorizationContext.h"
  #include "OpcUaStackCore/Application/ApplicationCloseSessionContext.h"

  class Library
  : public ApplicationIf
  {
    public:
    Library(void);
    virtual ~Library(void);

    //- ApplicationIf -----------------------------------------------------
    virtual bool startup(void);
    virtual bool shutdown(void);
    virtual std::string version(void);
    //- ApplicationIf -----------------------------------------------------

    private:
    void authenticationCallback(ApplicationAuthenticationContext* applicationAuthenitcationContext);
    void closeSessionCallback(ApplicationCloseSessionContext* applicationCloseSessionContext);
    void autorizationCallback(ApplicationAutorizationContext* applicationAutorizationContext);
  };

And add the following code to **Library.cpp**:

.. code-block:: cpp

  #include "OpcUaStackServer/ServiceSetApplication/RegisterForwardGlobal.h"

  bool
  Library::startup(void)
  {

    RegisterForwardGlobal registerForwardGlobal;
    registerForwardGlobal.setAuthenticationCallback(boost::bind(&Library::authenticationCallback, this, _1));
    registerForwardGlobal.setAutorizationCallback(boost::bind(&Library::autorizationCallback, this, _1));
    registerForwardGlobal.setCloseSessionCallback(boost::bind(&Library::closeSessionCallback, this, _1));
    if (!registerForwardGlobal.query(&this->service())) {
        std::cout << "registerForwardGlobal response error" << std::endl;
        return false;
    }

    return true;
  }

  void
  Library::authenticationCallback(
      ApplicationAuthenticationContext* applicationAuthenitcationContext)
  {

  }

  void
  Library::closeSessionCallback(
      ApplicationCloseSessionContext* applicationCloseSessionContext)
  {

  }

  void
  Library::autorizationCallback(
      ApplicationAutorizationContext* applicationAutorizationContext)
  {

  }

As you can see, we use *RegisterForwardGlobal* transaction for the registration our
callbacks in the stack. We wrap our handler-methods in bind-objects and pass them
to the transaction then we call *query* to send callbacks to the stack.

When the subscribed events happen, the stack calls handler-methods and pass them *context*
with input information and get result of the callback with it as well.

We'll show you how it's working in the next sections.


Authentication
--------------

To implement the authentication, our example should have some
list of allowed users. Since we'll need to pass information about the current
user between the stack and the application, we represent the user as a class
based on *UserContext* and make a map (*userMap_*) of them in **Library.h**:


.. code-block:: cpp

	class UserProfile : public UserContext {
	public:
    typedef boost::shared_ptr<UserProfile> SPtr;
    typedef std::map<std::string, UserProfile::SPtr> Map;
		UserProfile(std::string username, std::string password, std::string access)
			: username_(username)
			, password_(password)
			, access_(access)
		{

		}

		std::string username_;
		std::string password_;
		std::string access_;
	};

  class Library
  : public ApplicationIf
  {
    public:
    Library(void);
    virtual ~Library(void);

    //- ApplicationIf -----------------------------------------------------
    virtual bool startup(void);
    virtual bool shutdown(void);
    virtual std::string version(void);
    //- ApplicationIf -----------------------------------------------------

    private:
      void authenticationCallback(ApplicationAuthenticationContext* applicationAuthenitcationContext);
      void closeSessionCallback(ApplicationCloseSessionContext* applicationCloseSessionContext);
      void autorizationCallback(ApplicationAutorizationContext* applicationAutorizationContext);

      UserProfile::Map userMap_;
  };

Now we're placing two users to the map in  method *startup*. *User_RW* has right
to read and write data, *User_R* can only read:

.. code-block:: cpp

  bool
  Library::startup(void)
  {
      RegisterForwardGlobal registerForwardGlobal;
      registerForwardGlobal.setAuthenticationCallback(boost::bind(&Library::authenticationCallback, this, _1));
      registerForwardGlobal.setAutorizationCallback(boost::bind(&Library::autorizationCallback, this, _1));
      registerForwardGlobal.setCloseSessionCallback(boost::bind(&Library::closeSessionCallback, this, _1));
      if (!registerForwardGlobal.query(&this->service())) {
        std::cout << "registerForwardGlobal response error" << std::endl;
        return false;
      }

      userMap_ = UserProfile::Map();
      userMap_["User_RW"] = constructSPtr<UserProfile>("User_RW", "password1", "rw");
      userMap_["User_R"] = constructSPtr<UserProfile>("User_R", "password2", "r");

      return true;
  }


.. code-block:: cpp

  #include "OpcUaStackCore/ServiceSet/UserNameIdentityToken.h"

  // ...


Authorization
--------------

Close Session
--------------

References
-----------

* :ref:`security`
* :ref:`discovery_process`
* `Example <https://github.com/ASNeG/ASNeG-Demo/blob/master/src/ASNeG-Demo/Library/Authentication.cpp>`_

OPC UA Specification
--------------------

* Part 4 Services, 5.6 Session Service Set.
